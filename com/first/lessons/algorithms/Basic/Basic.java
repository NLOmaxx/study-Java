package com.lessons.algorithms.Basic;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Basic {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        extracted(reader);
        /*создаем новый массив с рандомным количеством ячеек
        от 5 до 1024*/
        int[] array = new int[arrGenerator()];
        /*записываем в него значения от 0 до конца массива*/
        for (int i = 0; i < array.length; i++) {
            array[i] = i;
        }
        /*генерируем число-победитель*/
        int win = randomGen(array.length);
        
        

        /*если делать все правильно, то не потребуется больше
        10 попыток. Мы вводим число и играем в горячо-холодно
        Если брать обычным перебором, или же базовым алгоритмом
        поиска, то 10 попыток нам не хватит и потребуется перебрать большую
        часть массива, если же взять бинарный перебор, который будет отсеивать
        значения например деля число каждый раз напополам, то с задачей можно будет
        справится в разы быстрее.

        Пример - всего 1024 ячейки, и в ячейке 764 спрятано искомое число.
        Базовым перебором, с начала, нам придется перебрать 763 значения,
        таким же базовым перебором с конца, нам придется перебрать 260 ячеек.
        Но при помощи бинарного перебора, мы можем поступать вот как.
        Делим на 2, получаем 512. Это меньше искомого, значит все значения до 512
        мы можем отсеять. Далее берем большое число, например 768. Это много,
        но мы уже отсеяли огромное количество значений, и это только с помощью
        степеней двойки. Ищем далее, более узко. 640 - мало, 701 - тоже мало.
        Значит, число лежит между 701 и 768. Далее, уже можно обойтись без степе
        ней двойки, но мы продолжим(предположим нам лень прописывать доп.условия)
        Отталкиваемся от 701, потому что остальное нам не нужно. 701+32=733, мало
        733+16=765 - много. 765-8=757, мало. Далее уже можно перебрать вручную,
        можно продолжать возиться со степенями двойки. Можно было также каждый раз делить
        напополам, это было бы проще, и потребовало бы меньше итераций. 7 явных итераций
        цикла + несколько 3-5 чтобы найти точное число. За 12 попыток кривого алгоритма
        мы нашли искомое число. Ниже приведена мини-игра, позволяющая вам испытать
        бинарный поиск воочию. Если вы будете перебирать не думая - вы проиграете)*/
        int max = array.length;
        int min = array[0];
        int temp = 0;
        System.out.println("Нужно найти: " + win);

        for(int i =0; i<=20; i++) {
            temp = (max+min)/2;
            if(temp < win) {
                System.out.println(temp + " - мало");
                min = temp;
            } else if(temp > win) {
                System.out.println(temp + " - много");
                max = temp;
            } else if(temp == win){
                System.out.println("В самый раз");
                System.out.println("Искомое число: " + temp);
                System.out.println("О(количество операций/скорость выполнения алгоритма = " + i);
                break;
            }
            
            /*Вообще О(n) - выполнение алгоритма в худшем случае
            То есть, данный алгоритм бинарного поиска будет отрабатывать
            следующим образом О(log n). n - в данной формуле максимальное
            количество значений. У нас оно 2 в 20 степени, а именно 1048675 операций
            бинарный логарифм(то есть по основанию 2), будет выглядеть так
            log₂1048675 = 20. То есть, наш алгоритм будет выглядеть так
            Количество операций для выполнения алгоритма равно 20, или же
            O(log n) = 20(в операциях)*/

        }
    }

    private static void extracted(BufferedReader reader) throws IOException {
    }

    public static int randomGen(int l) {
        double temp = Math.random() * l;
        float temp2 = Math.round(temp);
        int win = Math.round(temp2);
        return win;
    }

    public static int arrGenerator() {
        double temp = Math.random() * 1048576;
        float temp2 = Math.round(temp);
        int arrSize = Math.round(temp2);
        if (arrSize <= 2) {
            arrSize = arrSize + 5;
        }
        System.out.println("Размер массива: " + arrSize);
        return arrSize;
    }
    
}
